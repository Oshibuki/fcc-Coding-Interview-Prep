## 数据结构：找到二叉树中的最小值和最大值

在接下来的挑战中，我们来学习 tree（树）这种数据结构。在计算机科学中，树是一种很重要且常用的数据结构。之所以将这种数据结构称为树，是因为其结构很像真实生活中的树。树有一个叫做根节点（root node，可以类比树根）的初始节点，从根节点开始，通过分支（branch，可以类比树枝）链接其子节点，子节点又可以有其他的子节点，以此类推。如果要把这种数据结构画出来，一般会在最上面画根节点，就好象把真实世界中的树倒置过来。

首先，我们介绍几个树这种数据结构中的常见概念。根节点是树中最顶端的节点，即树的开始；树中的每个数据称为节点（node）；指向其他节点的节点称为父级节点（parent node），被指向的节点称为子节点（child node）。还有一些概念，你应该可以望文生义。子树指的是一个节点下所有的子级节点（注意，包含子级的子级，等等）；分支也可以叫做边缘（edges），叶子节点（leaf node）是指没有子节点的节点。其实，树本身是一种递归性的数据结构。也就是说，任何一个的子节点都是它们子树的父节点。在我们为树的操作设计算法时，一定要注意树的递归特性。

首先，我们来学习一种特殊的树——二叉树（binary tree）。更准确地说，我们现在要学的是二叉树中的一种特殊的类型——二叉查找树（binary search tree），我们先来解释一些概念。通常的树形数据结构中，一个节点可以有任意数量的分支。但二叉树中，每个节点最多只能有两个分支。此外，二叉查找树的子树会按一定规则排列，即每个节点左子树上的数值都小于等于该节点的数值；而每个节点右子树上的数值都大于等于该节点的数值。下面的图就代表一个二叉查找树，应该会对你理解这种数据类型有帮助：



![img](https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png)



子树的排列方式已经很直观了。你可以注意到根节点 8 左边的子树节点值都小于 8，而右边的值则都大于 8。而且，这种数值间的关系对于任何节点的子树都是成立的。例如，8 的左子树的根节点数值为 3，该节点有两个子节点——根据二叉查找树的规则，我们无需查看便可以知道左子树的各节点数值都小于 3，而右子树的各节点数值都大于 3，以此类推。

二叉查找树之所以有用且高效，是因为常用的操作比如查找元素、插入元素、删除元素等，需要的时间为对数级。如果你不理解这样的优势，可以与数组做个对比。对于一个长度为 n 的数组，找到元素的时间在 1（即第一个元素就是要找的）到 n（即最后一个元素才是要找的）之间。在寻找期间，我们没法跳过任何一个元素，只能一直往下，单向地寻找。因此我们说，在数组中找元素这个操作所需时间是与数组长度 n 线性相关的，它的时间复杂度我们记为 O(n)。而对于二叉查找树，我们只要比较当前节点与要找的数的大小，就可以知道该往左还是往右继续寻找。因此，在寻找元素的过程中，每一步都可以排除掉当前数据量的一半，我们可以用 0.5（代表一半）的 k（代表找到元素需要的步数）次方来表示。所以，对于总节点数为 n 的二叉查找树，找到一个元素所需步数 k 就是 log(2)n，即以 2 为底，n 的对数，排除一些不相干的因素（电脑性能，温度之类的），所需步数越多，时间也就越长，且两者线性相关。于是，它的时间复杂度我们可以记为 O(log(n))。注意，在 big O notation 中，常数是可以忽略的。至于 O(n) 到 O(log(n)) 是多大的提升，请你在纸上画出 y = x 和 y = log(2)x 的函数图像，然后你就懂了。如果看不明白上面的内容，请先去了解一下 big O notation 这种表示方式，在学习数据结构和算法时会经常提及。

挑战说明：我们先来做一个简单任务。我们已经在右边写好了二叉查找树的基本结构，其中我们定义了用来创建树中节点的函数。注意，每个节点都可能有左节点和右节点，而且我们可以给这些节点赋一个子树。现在我们需要在二叉查找树中定义`findMin`和`findMax`两个方法，它们应分别返回树中的最小值和最大值。你现在不需要考虑如何往树中添加节点，我们已经在后台为你实现了。如果你写不出，请回忆下二叉查找树的这一规律：左子树上的数值总是小于等于父节点的数值，而右子树上的数值总是大于等于父节点的数值。我们同时需要注意的是树中只会存储整数值。还有，如果树为空的话，所有方法都应该返回`null`。

```
var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));
function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
function BinarySearchTree() {
    this.root = null;
    // 请把你的代码写在这条注释以下
    this.findMin = function(){
      if(!this.root){
        return null
      }

      let current = this.root
      while(current.left){
        current = current.left
      }
      return current.value
    }

    this.findMax = function(){
      if(!this.root){
        return null
      }

      let current = this.root
      while(current.right){
        current = current.right
      }
      return current.value
    }
    // 请把你的代码写在这条注释以上
}
```

